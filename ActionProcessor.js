// ActionProcessor.js — extracted from v103-1/v118 (no refactors; same behavior)
const crypto = require('crypto');

// Keep defaults for consistency (not used heavily here but stable)
const DEFAULTS = {
  STREAM: { R: 2, P: 1 },
};

function sha256Hex(s) { return crypto.createHash('sha256').update(String(s),'utf8').digest('hex'); }
function parseISO(ts) { const d=new Date(ts); if (Number.isNaN(d.getTime())) throw new Error("INVALID_ISO_TIMESTAMP"); return d; }
function toISO(d) { return new Date(d).toISOString(); }

// Levenshtein + alias score (matching v118)
function levenshtein(a,b){
  a = String(a||'').toLowerCase(); b = String(b||'').toLowerCase();
  const n = a.length, m = b.length;
  const dp = new Array(m+1);
  for (let j=0;j<=m;j++) dp[j] = j;
  for (let i=1;i<=n;i++){
    let prev = dp[0];
    dp[0] = i;
    for (let j=1;j<=m;j++){
      const tmp = dp[j];
      const cost = (a[i-1]===b[j-1]) ? 0 : 1;
      dp[j] = Math.min(dp[j]+1, dp[j-1]+1, prev+cost);
      prev = tmp;
    }
  }
  return dp[m];
}
function aliasScore(query, name, aliases, ctxBonus=0){
  const q = String(query||'').trim().toLowerCase();
  let score = 0;
  if (q === String(name||'').trim().toLowerCase()) score += 10;
  if (Array.isArray(aliases) && aliases.some(al => q === String(al||'').trim().toLowerCase())) score += 6;
  const dists = [levenshtein(q, String(name||''))];
  if (Array.isArray(aliases)) for (const al of aliases) dists.push(levenshtein(q, String(al||'')));
  const dist = Math.min(...dists);
  if (dist > 2) score -= 2;
  score += Math.max(0, Math.min(ctxBonus, 4));
  return score;
}
function resolveItemByName(state, query){
  const inv = (((state||{}).player||{}).inventory)||[];
  const cands = [];
  for (const it of inv){
    const sc = aliasScore(query, it?.name||'', it?.aliases||[], 2);
    cands.push([sc, 'inventory', it]);
  }
  if (!cands.length) return null;
  cands.sort((a,b)=>b[0]-a[0]);
  const best = cands[0];
  const second = cands[1] || [-9999,'',{}];
  if (best[0] >= 20 && (best[0] - (typeof second[0]==='number'?second[0]:-9999)) >= 10){
    return [best[1], best[2]];
  }
  return null;
}

// Intent parsing (as in v118)
/* LEGACY FALLBACK — deprecated; used only if SemanticParser fails */
function parseIntent(text) {
  const t = String(text || '').trim().toLowerCase();
  if (/^(look|look around|observe|scan)$/.test(t)) return { action:'look' };
  let m;
  m = t.match(/^\b(grab|take|pick up)\b\s+(.*)$/); if (m){
    let target = (m[2]||'').trim().replace(/^(the|a|an)\s+/, '');
    if (!target) return { action:'noop' };
    return { action:'take', target };
  }
  m = t.match(/^\b(drop)\b\s+(.*)$/); if (m){
    let target = (m[2]||'').trim().replace(/^(the|a|an)\s+/, '');
    if (!target) return { action:'noop' };
    return { action:'drop', target };
  }
  // movement parsing moved to WorldGen.parseAndApplyMovement
}

// Merchant regeneration stub - prevents crashes, no state modification
function merchantRegenOnTurn(state, turnCount) {
  console.log(`[MERCHANT-REGEN] Stub called - turn ${turnCount}, merchants: ${state?.world?.npcs?.filter(n => n.type === 'merchant')?.length || 0}`);
  // TODO: Implement actual merchant inventory regeneration logic
  return state; // Return state unchanged for now
}

// Expiry tick + regen + player actions (take/drop/look)
// (movement handled by WorldGen; we still parse it so Engine can route)
function applyPlayerActions(state, actions, deltas, flags){
  const act = actions?.action;
  if (act === 'take'){ 
    // TODO: Implement take action logic
    console.log('[ACTIONS] Take action stub - needs implementation');
    return; 
  }
  if (act === 'drop'){
    const target = actions?.target||'';
    const res = resolveItemByName(state, target);
    if (res && res[0] === 'inventory'){
      const item = res[1];
      const inv = state.player.inventory;
      const idx = inv.findIndex(it => (it?.id) === item?.id);
      if (idx >= 0){
        inv.splice(idx,1);
        deltas.push({ op:'set', path:'/player/inventory', value: inv });
        flags.inventory_rev = true;
      }
    }
    return;
  }
  if (act === 'look'){ return; }
  
  // === PHASE 3C: Quest action execution ===
  if (['accept_quest', 'complete_quest'].includes(act)){
    updateNPCQuestState(actions, state, deltas, flags);
    return;
  }
}

function computeInventoryDigestHex(state){
  const inv = (((state||{}).player||{}).inventory)||[];
  const rows = inv.map(it => {
    const slot = ((it||{}).props||{}).slot || '';
    const rarity = ((it||{}).props||{}).rarity || '';
    const line = `${it?.id||''}|${it?.name||''}|${slot}|${rarity}|${it?.property_revision||0}`;
    return line;
  }).sort().join('\n');
  return sha256Hex(rows);
}

// === PHASE 3C: Settlement NPC lookup (persistent NPCs, not current cell) ===
function getNPCInSettlement(state, settlementId, npcId){
  const settlement = ((state?.world?.settlements)||{})[settlementId];
  if (!settlement || !Array.isArray(settlement.npcs)) return null;
  return settlement.npcs.find(n => n?.id === npcId) || null;
}

// === PHASE 3C: Quest action validation (no state mutation) ===
function validateQuestAction(action, targetNPC, state){
  const act = String(action?.action||'').toLowerCase();
  const npcId = action?.target; // NPC ID from normalized intent
  const questId = action?.questId; // Optional quest ID for complete_quest
  
  if (!npcId){
    return { valid: false, error: 'NO_NPC_TARGET', newState: null };
  }

  // Extract settlementId from NPC ID pattern: npc_${settlementId}_${index}
  const match = String(npcId).match(/^npc_([^_]+)_\d+$/);
  if (!match){
    return { valid: false, error: 'INVALID_NPC_ID_FORMAT', newState: null };
  }
  const settlementId = match[1];
  
  const npc = getNPCInSettlement(state, settlementId, npcId);
  if (!npc){
    return { valid: false, error: 'NPC_NOT_FOUND', newState: null };
  }

  // Check if NPC is a quest-giver
  if (typeof npc.quest_giver_rank !== 'number' || npc.quest_giver_rank <= 0){
    return { valid: false, error: 'NPC_NOT_QUEST_GIVER', newState: null };
  }

  const questState = (state?.quests) || { allQuestsSeeded: {}, active: [], completed: [], config: {} };
  
  if (act === 'accept_quest'){
    // Check: Quest available for this NPC
    const available = (questState.allQuestsSeeded[settlementId] || []).find(q => q.giver_npc_id === npcId);
    if (!available){
      return { valid: false, error: 'NO_QUEST_AVAILABLE', newState: null };
    }
    
    // Check: Not already active
    const alreadyActive = questState.active.some(q => q.id === available.id);
    if (alreadyActive){
      return { valid: false, error: 'QUEST_ALREADY_ACTIVE', newState: null };
    }
    
    // Check: Not already completed
    const alreadyCompleted = questState.completed.some(q => q.id === available.id);
    if (alreadyCompleted){
      return { valid: false, error: 'QUEST_ALREADY_COMPLETED', newState: null };
    }
    
    // Check: Max active quests limit
    const maxActive = questState.config?.maxActiveQuests || 10;
    if (questState.active.length >= maxActive){
      return { valid: false, error: 'MAX_ACTIVE_QUESTS_REACHED', newState: null };
    }
    
    return { valid: true, error: null, newState: { settlementId, questId: available.id, npc } };
  }
  
  if (act === 'complete_quest'){
    if (!questId){
      return { valid: false, error: 'NO_QUEST_ID', newState: null };
    }
    
    // Check: Quest is active
    const activeQuest = questState.active.find(q => q.id === questId);
    if (!activeQuest){
      return { valid: false, error: 'QUEST_NOT_ACTIVE', newState: null };
    }
    
    // Check: Quest is assigned to this NPC
    if (activeQuest.giver_npc_id !== npcId){
      return { valid: false, error: 'WRONG_QUEST_GIVER', newState: null };
    }
    
    // Check: Quest objectives completed (stub - assumes complete for now)
    // TODO: Implement objective validation when quest objective system is built
    
    return { valid: true, error: null, newState: { settlementId, questId, npc, activeQuest } };
  }
  
  if (act === 'ask_about_quest'){
    // Always valid if NPC is a quest-giver (no state constraints)
    return { valid: true, error: null, newState: { settlementId, npc } };
  }
  
  return { valid: false, error: 'UNKNOWN_QUEST_ACTION', newState: null };
}

// === PHASE 3C: NPC quest state persistence ===
function updateNPCQuestState(action, state, deltas, flags){
  const act = String(action?.action||'').toLowerCase();
  const validation = validateQuestAction(action, null, state);
  
  if (!validation.valid){
    console.log(`[QUEST] updateNPCQuestState failed: ${validation.error}`);
    return;
  }
  
  const { settlementId, questId, npc, activeQuest } = validation.newState;
  const settlement = state.world.settlements[settlementId];
  
  if (!settlement){
    console.log(`[QUEST] Settlement ${settlementId} not found`);
    return;
  }
  
  if (act === 'accept_quest'){
    // Add quest to active list
    const questState = state.quests || { allQuestsSeeded: {}, active: [], completed: [], config: {} };
    const questToAccept = (questState.allQuestsSeeded[settlementId] || []).find(q => q.id === questId);
    
    if (questToAccept){
      questState.active.push({
        ...questToAccept,
        accepted_at: new Date().toISOString(),
        status: 'active'
      });
      
      deltas.push({
        op: 'set',
        path: '/quests/active',
        value: questState.active
      });
      
      console.log(`[QUEST] Accepted quest ${questId} from NPC ${npc.id}`);
      flags.quest_accepted = true;
    }
  }
  
  if (act === 'complete_quest'){
    // Move quest from active to completed
    const questState = state.quests;
    const activeIdx = questState.active.findIndex(q => q.id === questId);
    
    if (activeIdx >= 0){
      const completedQuest = {
        ...questState.active[activeIdx],
        completed_at: new Date().toISOString(),
        status: 'completed'
      };
      
      questState.active.splice(activeIdx, 1);
      questState.completed.push(completedQuest);
      
      deltas.push({
        op: 'set',
        path: '/quests/active',
        value: questState.active
      });
      
      deltas.push({
        op: 'set',
        path: '/quests/completed',
        value: questState.completed
      });
      
      // Decrement NPC quest_giver_rank
      const npcIdx = settlement.npcs.findIndex(n => n.id === npc.id);
      if (npcIdx >= 0 && settlement.npcs[npcIdx].quest_giver_rank > 0){
        settlement.npcs[npcIdx].quest_giver_rank -= 1;
        
        deltas.push({
          op: 'set',
          path: `/world/settlements/${settlementId}/npcs`,
          value: settlement.npcs
        });
        
        console.log(`[QUEST] Completed quest ${questId}, NPC ${npc.id} rank: ${settlement.npcs[npcIdx].quest_giver_rank}`);
        flags.quest_completed = true;
      }
    }
  }
}

// === Phase 3: Validation for pre-normalized intents (no state mutation) ===
const DIR_ALIASES = { n:'north', s:'south', e:'east', w:'west', u:'up', d:'down' };
const VALID_DIRS = new Set(['north','south','east','west','up','down']);

function isValidDir(dir){
  if (!dir) return { ok:false, canonical:null };
  const d = String(dir).trim().toLowerCase();
  const canon = DIR_ALIASES[d] || d;
  return { ok: VALID_DIRS.has(canon), canonical: VALID_DIRS.has(canon) ? canon : null };
}

function getCellEntities(state){
  const cell = (((state||{}).world||{}).current_cell)||{};
  const items = Array.isArray(cell.items) ? cell.items : [];
  // If your schema nests npcs per cell, prefer that. Otherwise fallback to world.npcs array.
  const npcs = Array.isArray((((state||{}).world)||{}).npcs) ? state.world.npcs : (Array.isArray(cell.npcs)?cell.npcs:[]);
  return { items, npcs };
}

function findByNameCaseInsensitive(list, prop, query){
  const q = String(query||'').trim().toLowerCase();
  for (const it of (list||[])){
    const name = String(it?.[prop]||'').toLowerCase();
    if (name === q) return it;
  }
  return null;
}

function resolveCellItemByName(state, query){
  const { items } = getCellEntities(state);
  // Prefer aliasScore if available (matching inventory resolver style)
  let best = null;
  let bestScore = -1e9;
  for (const it of items){
    const score = (typeof aliasScore === 'function')
      ? aliasScore(query, it?.name||'', it?.aliases||[], 2)
      : (String(it?.name||'').toLowerCase() === String(query||'').trim().toLowerCase() ? 10 : 0);
    if (score > bestScore){ bestScore = score; best = it; }
  }
  return bestScore >= 6 ? best : null; // threshold similar to inventory resolver
}

function hasInventoryItem(state, name){
  const inv = (((state||{}).player||{}).inventory)||[];
  return !!findByNameCaseInsensitive(inv, 'name', name);
}

function isNPCPresent(state, name){
  const { npcs } = getCellEntities(state);
  return !!findByNameCaseInsensitive(npcs, 'name', name);
}
/**
 * validateAndQueueIntent(gameState, normalizedIntent)
 * Returns: { valid, queue, reason?, stateValidation? }
 */
function validateAndQueueIntent(state, normalizedIntent){
  const sv = { hasPlayer: !!((state||{}).player), notes: [] };

  if (!normalizedIntent || typeof normalizedIntent !== 'object'){
    return { valid:false, queue:[], reason:"NO_INTENT", stateValidation:sv };
  }
  const primary = normalizedIntent.primaryAction || null;
  if (!primary || typeof primary.action !== 'string' || !primary.action.trim()){
    return { valid:false, queue:[], reason:"NO_PRIMARY_ACTION", stateValidation:sv };
  }
  const secondaries = Array.isArray(normalizedIntent.secondaryActions) ? normalizedIntent.secondaryActions : [];
  const queue = normalizedIntent.compound ? [primary, ...secondaries] : [primary];

  // Validate each queued action without mutating state
  for (const act of queue){
    const action = String(act?.action||'').toLowerCase();
    if (!action){ return { valid:false, queue:[], reason:"EMPTY_ACTION", stateValidation:sv }; }

    if (action === 'move'){
      const { ok, canonical } = isValidDir(act?.dir);
      sv.validDir = ok;
      if (!ok) return { valid:false, queue:[], reason:"INVALID_DIRECTION", stateValidation:sv };
      act.dir = canonical; // canonicalize
      continue;
    }

    if (action === 'take'){
      const target = act?.target||'';
      const found = resolveCellItemByName(state, target);
      sv.targetInCell = !!found;
      if (!found) return { valid:false, queue:[], reason:"TARGET_NOT_FOUND_IN_CELL", stateValidation:sv };
      continue;
    }

    if (action === 'drop'){
      const target = act?.target||'';
      const inInv = hasInventoryItem(state, target);
      sv.targetInInventory = inInv;
      if (!inInv) return { valid:false, queue:[], reason:"TARGET_NOT_IN_INVENTORY", stateValidation:sv };
      continue;
    }

    if (action === 'examine'){
      const t = act?.target||'';
      const inCell = !!resolveCellItemByName(state, t);
      const inInv = hasInventoryItem(state, t);
      const npc   = isNPCPresent(state, t);
      sv.visible = !!(inCell || inInv || npc);
      if (!sv.visible) return { valid:false, queue:[], reason:"TARGET_NOT_VISIBLE", stateValidation:sv };
      continue;
    }

    if (action === 'talk'){
      const t = act?.target||'';
      const present = isNPCPresent(state, t);
      sv.targetIsNPC = present;
      if (!present) return { valid:false, queue:[], reason:"NPC_NOT_PRESENT", stateValidation:sv };
      continue;
    }

    // === PHASE 3C: Quest action validation ===
    if (['accept_quest', 'complete_quest', 'ask_about_quest'].includes(action)){
      const questValidation = validateQuestAction(act, null, state);
      sv.questValidation = questValidation;
      if (!questValidation.valid){
        return { valid:false, queue:[], reason:questValidation.error, stateValidation:sv };
      }
      continue;
    }

    // Lightweight checks / always-allow group
    if (['sit','stand','wait','listen','look','inventory','help'].includes(action)){
      continue;
    }

    // Actions that may need deeper model checks; allow if not modeled here
    if (['cast','attack','sneak'].includes(action)){
      sv.notes.push(`allowed_${action}_shallow`);
      continue;
    }

    // Unknown action: pass through but mark as shallow-validated
    sv.notes.push(`unknown_action:${action}`);
  }

  console.log('[ACTIONS] valid queue=%d primary=%s', queue.length, queue[0]?.action);
  return { valid:true, queue, stateValidation:sv };
}

module.exports = {
  validateAndQueueIntent,
  parseIntent,
  applyPlayerActions,
  computeInventoryDigestHex,
  resolveItemByName,
  isValidDir,
  getCellEntities,
  findByNameCaseInsensitive,
  resolveCellItemByName,
  hasInventoryItem,
  isNPCPresent,
  // New exports to prevent crashes and improve utility access
  merchantRegenOnTurn,
  aliasScore,
  levenshtein,
  parseISO,
  toISO,
  sha256Hex,
  // === PHASE 3C: Quest system exports ===
  getNPCInSettlement,
  validateQuestAction,
  updateNPCQuestState
};
